!===============================================================================
!
! quda_fortran.F90
!
!-------------------------------------------------------------------------------
!
! This is a Fortran module that implements the C structs defined in
! quda.h as Fortran modules.  This is currently generated by hand, and
! so must be matched against an appropriate version of QUDA.  It would
! be nice to auto-generate this from quda.h.
!
!-------------------------------------------------------------------------------
# include <enum_quda_fortran.h>

!-------------------------------------------------------------------------------

#include <quda_constants.h>

module quda_fortran

  ! This corresponds to the QudaGaugeParam struct in quda.h
  type quda_gauge_param

     integer(8) :: struct_size  ! Size of this struct in bytes

     QudaFieldLocation :: location !The location of the gauge field

     integer(4), dimension(4) :: x

     real(8) :: anisotropy    !Used for Wilson and Wilson-clover
     real(8) :: tadpole_coeff !Used for staggered only
     real(8) :: scale         !Used by staggered long links

     QudaLinkType :: link_type
     QudaGaugeFieldOrder :: gauge_order
     QudaTboundary :: t_boundary
     QudaPrecision :: cpu_prec
     QudaPrecision :: cuda_prec
     QudaReconstructType :: reconstruct
     QudaPrecision :: cuda_prec_sloppy
     QudaReconstructType :: reconstruct_sloppy
     QudaPrecision :: cuda_prec_refinement_sloppy
     QudaReconstructType :: reconstruct_refinement_sloppy
     QudaPrecision :: cuda_prec_precondition
     QudaReconstructType :: reconstruct_precondition
     QudaPrecision :: cuda_prec_eigensolver
     QudaReconstructType :: reconstruct_eigensolver
     QudaGaugeFixed :: gauge_fix

     integer(4) :: ga_pad

     integer(4) :: site_ga_pad ! Used by link fattening and the gauge and fermion forces

     integer(4) :: staple_pad   ! Used by link fattening
     integer(4) :: llfat_ga_pad ! Used by link fattening
     integer(4) :: mom_ga_pad   ! Used by the gauge and fermion forces

     ! Set the staggered phase type of the links
     QudaStaggeredPhase :: staggered_phase_type
     ! Whether the staggered phase has already been applied to the links
     integer(4) :: staggered_phase_applied

     ! Imaginary chemical potential
     real(8) :: i_mu

     integer(4) :: overlap ! width of domain overlap

     ! When computing momentum, should we overwrite it or accumulate
     ! to it (only presently used in gauge-force)
     integer(4) :: overwrite_mom

     ! When computing products of gauge links, should we overwrite the output or accumulate
     ! to it? (only presently used in gauge-path)
     integer(4) :: overwrite_gauge

     integer(4) :: use_resident_gauge  ! Use the resident gauge field
     integer(4) :: use_resident_mom    ! Use the resident momentume field
     integer(4) :: make_resident_gauge ! Make the result gauge field resident
     integer(4) :: make_resident_mom   ! Make the result momentum field resident
     integer(4) :: return_result_gauge ! Return the result gauge field
     integer(4) :: return_result_mom   ! Return the result momentum field

     integer(8) :: gauge_offset ! Offset into MILC site struct to the gauge field (only if gauge_order=MILC_SITE_GAUGE_ORDER)
     integer(8) :: mom_offset   ! Offset into MILC site struct to the momentum field (only if gauge_order=MILC_SITE_GAUGE_ORDER)
     integer(8) :: site_size    ! Size of MILC site struct (only if gauge_order=MILC_SITE_GAUGE_ORDER)
  end type quda_gauge_param

  ! This module corresponds to the QudaInvertParam struct in quda.h
  type quda_invert_param

     integer(8) :: struct_size  ! Size of this struct in bytes

     QudaFieldLocation :: input_location  ! The location of the input field
     QudaFieldLocation :: output_location ! The location of the output field

     QudaDslashType :: dslash_type
     QudaInverterType :: inv_type

     real(8) :: mass  ! Used for staggered only
     real(8) :: kappa ! Used for Wilson and Wilson-clover

     real(8) :: m5    ! Domain wall height
     integer(4) :: Ls       ! Extent of the 5th dimension (for domain wall)

     complex(8), dimension(QUDA_MAX_DWF_LS) :: b_5 ! MDWF coefficients
     complex(8), dimension(QUDA_MAX_DWF_LS) :: c_5 ! MDWF coefficients

     real(8) :: eofa_shift; ! EOFA parameter
     integer(4) :: eofa_pm; ! EOFA parameter
     real(8) :: mq1; ! EOFA parameter
     real(8) :: mq2; ! EOFA parameter
     real(8) :: mq3; ! EOFA parameter

     real(8) :: mu    ! Chiral twisted mass parameter
     real(8) :: tm_rho ! Chiral twisted mass shift used for Hasenbusch mass preconditioning for twisted clover
     real(8) :: epsilon ! Flavor twisted mass parameter
     QudaTwistFlavorType :: twist_flavor  ! Twisted mass flavor

     integer(4) :: laplace3D    ! direction to omit in Laplace
     
     real(8) :: tol ! Requested L2 residual norm
     real(8) :: tol_restart ! Solver tolerance in the L2 residual norm (used to restart InitCG)
     real(8) :: tol_hq ! Requested heavy quark residual norm
     integer(4) :: compute_true_res ! Whether to compute the true residual post solve
     real(8) :: true_res ! Actual L2 residual norm achieved in solver
     real(8) :: true_res_hq ! Actual heavy quark residual norm achieved in solver
     integer(4) :: maxiter
     real(8) :: reliable_delta ! Reliable update tolerance
     real(8) :: reliable_delta_refinement ! Reliable update tolerance used in post multi-shift solver refinement
     integer(4) :: use_alternative_reliable ! Whether to use alternative reliable updates
     integer(4) :: use_sloppy_partial_accumulator ! Whether to keep the partial solution accumuator in sloppy precision
     integer(4) :: solution_accumulator_pipeline ! How many direction vectors we accumulate into the solution vector at once
     integer(4) :: max_res_increase ! How many residual increases we tolerate when doing reliable updates
     integer(4) :: max_res_increase_total ! Total number of residual increases we tolerate
     integer(4) :: max_hq_res_increase ! How many heavy-quark residual increases we tolerate when doing heavy-quark restarts
     integer(4) :: max_hq_res_increase_total ! Total number of heavy-quark residual restarts we tolerate
     integer(4) :: heavy_quark_check ! After how many iterations shall the heavy quark residual be updated
     integer(4) :: pipeline ! Whether to enable pipeline solver option
     integer(4) :: num_offset ! Number of offsets in the multi-shift solver
     integer(4) :: num_src ! Number of sources in the multiple source solver
     integer(4) :: num_src_per_sub_partition ! Number of sources in the multiple source solver, but per sub-partition

     integer(4), dimension(QUDA_MAX_DIM) :: split_grid ! The grid of sub-partition according to which the processor grid will be partitioned

     integer(4) :: overlap ! width of domain overlaps
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: offset ! Offsets for multi-shift solver
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: tol_offset ! Solver tolerance for each offset

     ! Solver tolerance for each shift when refinement is applied using the heavy-quark residual
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: tol_hq_offset

     ! Actual L2 residual norm achieved in solver for each offset
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: true_res_offset

     ! Iterated L2 residual achieved in multi shift solver for each offset
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: iter_res_offset

     ! Actual heavy quark residual norm achieved in solver for each offset
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: true_res_hq_offset

     ! Residuals in the partial faction expansion
     real(8), dimension(QUDA_MAX_MULTI_SHIFT) :: residue

     ! Whether we should evaluate the action after the linear solve
     integer(4) :: compute_action

     ! Computed value of the bilinear action (complex valued)
     !   invert: \phi^\dagger A^{-1} \phi
     !   multishift: \phi^\dagger r(x) \phi = \phi^\dagger (sum_k residue[k] * (A + offset[k])^{-1} ) \phi
     real(8), dimension(2) :: action

     QudaSolutionType :: solution_type  ! Type of system to solve
     QudaSolveType :: solve_type        ! How to solve it
     QudaMatPCType :: matpc_type
     QudaDagType :: dagger
     QudaMassNormalization :: mass_normalization

     QudaSolverNormalization :: solver_normalization
     QudaPreserveSource :: preserve_source

     QudaPrecision :: cpu_prec
     QudaPrecision :: cuda_prec
     QudaPrecision :: cuda_prec_sloppy
     QudaPrecision :: cuda_prec_refinement_sloppy
     QudaPrecision :: cuda_prec_precondition
     QudaPrecision :: cuda_prec_eigensolver

     QudaDiracFieldOrder :: dirac_order

     ! Gamma basis of the input and output host fields
     QudaGammaBasis :: gamma_basis

     QudaFieldLocation :: clover_location            ! The location of the clover field
     QudaPrecision :: clover_cpu_prec
     QudaPrecision :: clover_cuda_prec
     QudaPrecision :: clover_cuda_prec_sloppy
     QudaPrecision :: clover_cuda_prec_refinement_sloppy
     QudaPrecision :: clover_cuda_prec_precondition
     QudaPrecision :: clover_cuda_prec_eigensolver

     QudaCloverFieldOrder :: clover_order
     QudaUseInitGuess :: use_init_guess

     real(8) :: clover_csw   ! Csw coefficient of the clover term
     real(8) :: clover_coeff ! Coefficient of the clover term
     real(8) :: clover_rho   ! Real number added to the clover diagonal (not to inverse)
     integer(4) :: compute_clover_trlog ! Whether to compute the trace log of the clover term
     real(8), dimension(2) :: trlogA    ! The trace log of the clover term (even/odd computed separately)

     integer(4) :: compute_clover                    ! Whether to compute the clover field
     integer(4) :: compute_clover_inverse            ! Whether to compute the clover inverse field
     integer(4) :: return_clover                     ! Whether to copy back the clover matrix field
     integer(4) :: return_clover_inverse             ! Whether to copy back the inverted clover matrix field

     QudaVerbosity :: verbosity                      ! The verbosity setting to use in the solver

     integer(4) :: iter
     real(8) :: gflops
     real(8) :: secs

     ! Enable auto-tuning?
     QudaTune :: tune

     ! Number of steps in s-step algorithms
     integer(4) :: nsteps

     ! Maximum size of Krylov space used by solver
     integer(4) :: gcr_nkrylov

     ! The following parameters are related to the domain-decomposed preconditioner.

     ! The inner Krylov solver used in the preconditioner.  Set to
     ! QUDA_INVALID_INVERTER to disable the preconditioner entirely.
     QudaInverterType :: inv_type_precondition

     ! pointer to preconditioner instance
     integer(8) :: preconditioner

     ! pointer to deflation instance
     integer(8) :: deflation_op

     ! pointer to QudaEigParam that defines any deflation
     integer(8) :: eig_param

     ! If true, deflate the initial guess
     QudaBoolean :: deflate

     ! Dslash used in the inner Krylov solver
     QudaDslashType :: dslash_type_precondition

     ! Verbosity of the inner Krylov solver
     QudaVerbosity :: verbosity_precondition

     ! Tolerance in the inner solver
     real(8) :: tol_precondition

     ! Maximum number of iterations allowed in the inner solver
     integer(4) :: maxiter_precondition

     ! Relaxation parameter used in GCR-DD (default = 1.0)
     real(8) :: omega

     ! Basis for CA algorithms
     QudaCABasis :: ca_basis

     ! Minimum eigenvalue for Chebyshev CA basis
     real(8) :: ca_lambda_min

     ! Maximum eigenvalue for Chebyshev CA basis
     real(8) :: ca_lambda_max

     ! Basis for CA algorithms in preconditioner solvers
     QudaCABasis :: ca_basis_precondition

     ! Minimum eigenvalue for Chebyshev CA basis in preconditioner solvers
     real(8) :: ca_lambda_min_precondition

     ! Maximum eigenvalue for Chebyshev CA basis in preconditioner solvers
     real(8) :: ca_lambda_max_precondition

     ! Number of preconditioner cycles to perform per iteration
     integer(4) :: precondition_cycle

     ! Whether to use additive or multiplicative Schwarz preconditioning
     QudaSchwarzType :: schwarz_type

     ! The type of accelerator type to use for preconditioner
     QudaAcceleratorType :: accelerator_type_precondition

     ! The diagonal constant to suppress the low modes when performing 5D transfer
     real(8):: madwf_diagonal_suppressor

     ! The target MADWF Ls to be used in the accelerator
     integer(4):: madwf_ls

     ! The minimum number of iterations after which to generate the null vectors for MADWF
     integer(4):: madwf_null_miniter

     ! The maximum tolerance after which to generate the null vectors for MADWF
     real(8):: madwf_null_tol

     ! The maximum number of iterations for the training iterations
     integer(4):: madwf_train_maxiter

     ! Whether to load the MADWF parameters from the file system
     QudaBoolean:: madwf_param_load

     ! Whether to save the MADWF parameters to the file system
     QudaBoolean:: madwf_param_save

     ! Path to load from the file system
     character(len=256):: madwf_param_infile

     ! Path to save to the file system
     character(len=256):: madwf_param_outfile

     ! Whether to use the Fermilab heavy-quark residual or standard residual to gauge convergence
     QudaResidualType ::residual_type

     ! Parameters for deflated solvers
     QudaPrecision :: cuda_prec_ritz ! The precision of the Ritz vectors
     integer(4)::nev
     integer(4)::max_search_dim ! for magma library this parameter must be multiple 16?
     integer(4)::rhs_idx
     integer(4)::deflation_grid !total deflation space is nev*deflation_grid
     real(8):: eigenval_tol ! eigCG: selection criterion for the reduced eigenvector set
     integer(4)::eigcg_max_restarts ! mixed precision eigCG tuning parameter:  minimum search vector space restarts
     integer(4)::max_restart_num     ! initCG tuning parameter:  maximum restarts
     real(8)::inc_tol     ! initCG tuning parameter:  decrease in absolute value of the residual within each restart cycle

     ! Parameters for setting data residency of the solver
     integer(4)::make_resident_solution ! Whether to make the solution vector(s) after the solve
     integer(4)::use_resident_solution  ! Whether to use the resident solution vector(s)

     ! Whether to use the solution vector to augment the chronological forecast
     integer(4)::chrono_make_resident

     !Whether the solution should replace the last entry in the chronology */
     integer(4)::chrono_replace_last

     ! Whether to use the resident chronological basis
     integer(4)::chrono_use_resident

     ! The maximum length of the chronological history to store
     integer(4)::chrono_max_dim

     ! The index to indeicate which chrono history we are augmenting */
     integer(4)::chrono_index

     ! Precision to store the chronological basis in
     integer(4)::chrono_precision;

     ! Which external library to use in the linear solvers (Eigen) */
     QudaExtLibType :: extlib_type

     ! Whether to use the platform native or generic BLAS / LAPACK */
     QudaBoolean :: native_blas_lapack;

     ! Whether to use the fused kernels for Mobius/DWF-4D dslash
     QudaBoolean :: use_mobius_fused_kernel

  end type quda_invert_param

end module quda_fortran
!===============================================================================
